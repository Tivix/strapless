// utilities

.hide, .hidden { display: none !important;}

.clearfix { .clearfix();}

.make-color-classes-for(@semantic-colors);

#sl-tools {
	.quadratic-compare(@midpoint, @c1, @c2) {
		// compares c1 and c2 to midpoint, assigns @winner to farthest in rgb-space

		@r-values-m-c1: 2*(red(@c1) - red(@midpoint))*(red(@c1) - red(@midpoint));
		@g-values-m-c1: 4*(green(@c1) - green(@midpoint))*(green(@c1) - green(@midpoint));
		@b-values-m-c1: 3*(blue(@c1) - blue(@midpoint))*(blue(@c1) - blue(@midpoint));

		@r-values-m-c2: 2*(red(@c2) - red(@midpoint))*(red(@c2) - red(@midpoint));
		@g-values-m-c2: 4*(green(@c2) - green(@midpoint))*(green(@c2) - green(@midpoint));
		@b-values-m-c2: 3*(blue(@c2) - blue(@midpoint))*(blue(@c2) - blue(@midpoint));

		@d-m-c1: sqrt(@r-values-m-c1 + @g-values-m-c1 + @b-values-m-c1);
		@d-m-c2: sqrt(@r-values-m-c2 + @g-values-m-c2 + @b-values-m-c2);

		.resolve();

		.resolve() when (@d-m-c2 > @d-m-c1) {
			@winner: @c2;
		}

		.resolve() when (default()) {
			@winner: @c1;
		}
	}
}


.sl-bg-catch(@color: @background) {
  // users can select any seed color but not bg, this catches bad ones and shows something better
  
  body {
  	.colorize(@color1a);
  }

  & when (luma(@color) > 88%) {
    // above a certain brightness, just use white
    body {
      .colorize(white);
    }
  }

  & when (saturation(@color) > 80%) {
    // for really saturated colors, use white
    body {
      .colorize(white);
    }
  }

  & when (luma(@color) < 20%) {
    body {
      .colorize(@color1c);
    }
  }

  & when (luma(@color) < 10%) {
    // for really dark schemes use a dark gray for better color pop
    body {
      .colorize(@gray-darker);
    }
  }
}